<h1><center>零、OS的28个前置问题</center></h1>

## 一、操作系统是什么

操作系统是管理软硬件资源的程序。



## 二、你想研究到什么程度

操作系统研究到什么程度，还是走一步算一步吧。



## 三、写操作系统，哪些需要我来做

写操作系统需要了解硬件，这些硬件提供了软件方面的接口（指令集），这样我们的操作系统通过软件（计算机指令）就能够控制硬件。我们需要做的就是知道如何通过计算机指令来控制硬件。因此需要参考硬件手册。



## 四、软件是如何访问硬件的

软件访问硬件有两种方式：

1. memory mapped io

   将某个外设的内存映射到一定范围的地址空间中，CPU 通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。

2. isolated io

   外设是通过 IO 接口与 CPU 通信的，CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递给另一端的外设，也就是说CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口。

   IO 接口上面有一些寄存器，访问 IO 接口本质上就是访问这些寄存器，这些寄存器就是人们常说的端口。



## 五、应用程序是什么，和操作系统是如何配合到一起的

应用程序和操作系统一样，是软件。

应用程序是通过系统调用来和操作系统配合完成某项功能的。系统调用是我们包含的头文件中的运行时库完成的。



## 六、为什么称为陷入内核

如果将CR0—CR3画成同心圆的话，最内层的圆圈是CR0，在外层的圆圈是CR3。

用户级进程是运行在CR3特权级的，内核是运行在CR0特权级的，当想要使用内核代码时，就好像从外围陷入了圆心，就是“陷入”



## 七、内存访问为什么要分段

寄存器是16bit，但是地址总线是20位，16bit的话只能访问64kB的内存，但是地址总线20位，也就是1MB，怎么办呢？——段基址：段内偏移量。让段基址左移4位后，加上段内偏移量。这样就是20位的地址了。



## 八、代码中为什么分为代码段、数据段？这和内存访问机制中的段是一回事吗

代码分为代码段、数据段是为了便于管理，因为程序中代码和数据的访问权限是不一样的，代码段是可读可执行，而数据段是可读可写。它们的权限不同，你用代码段的权限去访问数据段，这显然是错误的。



## 九、物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

CPU处于实模式的时候，通过`段基址：段内偏移量`这种访址方式最后得到的就是物理地址，是实打实的、真正的内存地址。

当CPU处于保护模式的时候，`段基址：段内偏移量`得到的地址被称为线性地址，当开启了分页功能后，这个线性地址又被称为虚拟地址，虚拟地址需要转换成物理地址才能被CPU送上地址总线去访问内存。如果没有开启分页功能，此线性地址就是物理地址，可以直接访问内存。

段内偏移量被称为有效地址，也称为逻辑地址。

![image-20220430202018102](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202204302020322.png)



## 十、什么是段重叠

我们在使用`段基址：段内偏移量`访问某个内存地址的时候，由于段基址不是固定的，所以我们可以使用不同的段基址配合上变化的段内偏移量来访问某个内存地址，这时，不同的`段基址：段内偏移量`之间会有可访问区域的重叠，这就是段重叠。



## 十一、什么是平坦模型

平坦模型是相对于多段模型而言的，平坦模型就是把整个内存区域当成一个段。当CPU处于保护模式时，内存地址是32位的，内存空间大小是4GB，段基址从0x0开始，段内偏移量也是32位的，刚好能够访问的最大内存区域就是4GB，因此只用一个段就可以了。



## 十二、cs、ds这类sreg段寄存器，位宽是多少

位宽是16bit。



## 十三、什么是工程，什么是协议

工程是指开发一套软件所需要的全部文件，包括配置环境。

协议是一种大家共同遵守的规约，主要用来实现通信、共享、协作；起初是为避免大家各干各的，无法彼此调用对方成果的情况，从而给大家统一一种接口、一组数据调用或者分析的约定。



## 十四、为什么Linux系统下的应用程序不能在Windows系统下运行

1. 目标文件的格式不同。

   * Linux 下的可执行程序格式是 elf，也就是 “Executable and Linking Format”
   * Windows 下的可执行程序是 PE 格式（portable executable，可移植的可执行文件）

2. 操作系统的API不同

   * Linux 中的 API 称为系统调用，是通过 int 0x80 这个软中断实现的
   * Windows 中的 API 是存放在动态链接库 DLL中的，即 Dynamic Link Library 

   

## 十五、局部变量和函数参数为什么要放在栈中

1. 局部变量

   * 放在栈中，用过就清理，节省内存

2. 函数参数

   * 函数参数是局部的变量，只有自己用

   * 为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，如果是递归调用的话，参数及返回值需要的内存空间也就不确定了，这取决于递归的次数。所以放在栈中，为函数的参数和返回地址动态分配内存



## 十六、为什么说汇编语言比C语言快

汇编语言和C语言不都是被编译成机器码由CPU运行的吗？那么为什么说汇编语言比C语言更快呢？

因为C语言中考虑到安全性、通用性等问题，会有额外的代码，因此当C语言被编译成机器码时，这些额外代码也被编译成机器码了。

而汇编语言的每个助记符直接对应一个机器码，它没有额外的解决安全性、通用性等功能的代码，因此它被汇编成机器码时更纯粹。



## 十七、先有的语言，还是先有的编译器，第1个编译器是怎么产生的

先有的语言。



## 十八、编译型程序与解释型程序的区别

编译型程序其在执行时是一个进程，进程调度器是可以看到这个进程的。编译型程序在执行时，是操作系统在执行它。

解释型程序其在运行时，是运行在它的解释器中的，它的解释器是一个进程，进程调度器只能看到其解释器的进程。至于你写的解释型程序的运行，是解释器在执行它，不是操作系统。



## 十九、什么是大端字节序、小端字节序

（1）小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。

（2）大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。。

它们各有优点：

小端字节序的优点：

* 因为在做强制数据类型转换时，如果转换是由低精度转向高精度，这数值本身没什么变化，如 short 是 2 字节，将其转换为 4 字节的 int 类型，无非是由 0x1234 变成了 0x00001234，数值上是不变的，只是存储形式上变了。
* 如果转换是高精度转向低精度，也就是多个字节的数值要减少一些存储字节，这必然是要丢弃一部分数值。编译器的转换原则是强制转换到低精度类型，丢弃数值的高字节位，只保留数值的低字节

![image-20220502173108457](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205021731618.png)

0x12345678的10进制就是汇编代码低7行的305419896。

汇编第8行将0x12345678写入寄存器eax中，此时eax的数据为：

![image-20220502174124410](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205021741468.png)

汇编第9行将ax符号扩展为eax。

汇编第10行，将eax，此时为变量b的结果保存在栈的rbp-8地址处。



最后输出结果为：

![image-20220502173152253](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205021731297.png)

从上图就可以看出，在高精度向低精度转换时，将高位截去，保存低位。很合理。



大端字节序的优点：

* 最高位在最低地址，也就是直接就可以取到了，不用再跨越几个字节，减少了时钟周期。另外，对于人类来说，还是大端看上去顺眼，毕竟咱们存储 0x12345678 到内存时，它在内存中的存储顺序也是 0x12345678，而不是 0x78563412，这样看上去才直观



## 二十、BIOS中断、DOS中断、Linux中断的区别

BIOS 和 DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令` int 中断号`来调用的。

中断向量表中的每个中断向量大小是 4 字节。这 4 字节描述了一个中断处理程序的段基址和段内偏移地址。因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序。

计算机启动之初，中断向量表中的中断处理程序是由 BIOS 建立的，它从物理内存地址 0x0000 处初始化并在中断向量表中添加各种中断处理程序。

1. BIOS中断

   BIOS是运行在实模式下的，故其建立的中断调用是建立在中断向量表中。BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行

2. DOS中断

   DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS的不能冲突

3. Linux中断

   Linux 内核是在进入保护模式后才建立中断处理程序的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）



## 二十一、Sction和Segment的区别

一个segment中，是由多个性质相同的section组成的。



## 二十二、什么是魔数

魔数，如其名，就是不知意义的数字。在程序中直接给出数字，我们不知道它的具体含义，这就是魔数。



## 二十三、操作系统是如何识别文件系统的

一个硬盘上可以有很多分区，每个分区的格式又可以不同。就拿 Linux 来说，既能识别 ext3，又能识别 ext4文件系统。那么它是如何办到的呢？

各分区都有超级块，一般位于本分区的第 2 个扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，比对此值便知道文件系统类型了。



## 二十四、如何控制CPU的下一条指令

CPU要执行的下一条指令的地址保存在CS:IP中，那么这个地址是如何计算的呢？

这个地址是当前执行指令的地址+指令的大小，就得到了下一条指令的内存地址。

也就是说如何控制CPU要执行的下一条指令是通过改变CS:IP寄存器的值来实现的。

那具体有哪些实现方式呢：jmp、int、ret、call，或者正常的当前指令地址+指令大小来改变CS:IP的值，实现控制CPU的下一条指令。

在ARM中，可以通过mov指令来改变PC的值。如：

```assembly
mov pc, r0 # 将ro寄存器中的值，传递给pc寄存器
```



## 二十五、指令集、体系结构、微架构、编程语言

指令集是具体的一套指令编码。

体系结构不仅仅是有指令集，它还有内存布局，寄存器组。

yale patt的书中就有这样的表述：`The ISA specifies the memory organization, register set, and instruction set, including the opcodes, data types, and addressing modes of the instructions in the instruction set.`

微架构是指令集的物理实现方式。比方说像x86指令集，intel和amd的微架构就是不一样的。

至于编程语言，它最终需要由编译器编译成具体硬件平台的可执行文件。



## 二十六、库函数是用户进程与内核的桥梁

用户要完成一件事情需要内核的帮助。我们以最简单的Hello World程序为例：

```c
#include<stdio.h>
int main() {
    printf("%s\n", "Hello World");
    
    return 0;
}
```

我们前面讲编译型程序和解释型程序的时候讲过，编译型程序在执行时是一个进程，所以这个C程序在执行的时候，就是一个用户进程。这个用户进程调用了printf函数，那么这个printf函数在哪里呢？

printf函数在CRT(C Run Time library)里面，在链接阶段会把含有printf函数的.o目标文件链接进程序中。

那么”与内核的桥梁“这个”桥梁“的作用体现在什么地方呢？

那就是在printf函数中，它会调用`SYS_write`这个系统调用。在执行这个系统调用时，就要执行操作系统的内核代码了。此时，库函数就实现了用户进程和内核的桥梁作用。左边是用户进程，右边是内核，连接用户进程和内核的就是库函数，库函数中调用了系统调用。



## 二十七、转义字符与ASCII码

计算机只能识别0和1，那么就需要把字符转换成0和1，ASCII码就是字符和0、1串的映射关系表。

ASCII码中有可见字符和不可见字符，不可见字符需要通过转义字符使其”可视化“。

例如：

abc\n，这个\n就是不可见字符换行的可视化表示，我们通过键盘输入\和n和这是两个ASCII码，一个ASCII码代表\，一个ASCII码代表n。

那么操作系统如何实现换行呢？

这就是编译器的功劳了，编译器在处理字符串时，是一个字符一个字符处理的，当编译器发现当前字符是\时，它会继续获取下一个字符，并将这两个字符组合成一个整体，最后的ASCII码是\n这个整体的ASCII码。



## 二十八、MBR、EBR、DBR和OBR各是什么

#### （一）MBR是main boot record主引导记录。

MBR位于整个硬盘最开始的扇区，也就是0盘0道1扇区，这个扇区称为MBR引导扇区。在这个扇区中，有3样东西：

1. 446字节的引导程序及参数。在MBR引导扇区中存储引导程序为的是从BIOS手中接下CPU的控制权
2. 64字节的分区表。记住这个分区表，在BIOS转交CPU控制权的时候，我们会用到
3. 2字节的结束标记0x55和0xaa



#### （二）EBR是expand boot record扩展引导记录



#### （三）DBR是Dos Boot Record Dos操作系统的引导记录

DBR是OBR的祖先，OBR是从DBR遗留下来的，理解OBR要先理解DBR。

DBR中有5样东西：

1. 跳转指令，使MBR跳转到引导代码
2. 产商信息，DOS版本信息
3. BIOS参数块BPB，BIOS Parameter Block
4. 操作系统引导程序
5. 结束标记0x55和0xaa

在 DOS 时代只有 4 个分区，不存在扩展分区，这 4 个分区都相当于主分区，所以各主分区最开始的扇区称为 DBR 引导扇区。后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，分区最开始的扇区都作为 DOS 引导扇区。

其他操作系统如 UNIX，Linux 等为了兼容 MBR 也传承了这个习俗，都将各分区最开始的扇区作为自己的引导扇区，在里面存放自己操作系统的引导程序。

由于现在这个“分区最开始的扇区”引导的操作系统类型太多了，不仅仅只是DOS操作系统，而且 DOS 还退出历史舞台了，所以 DBR 也称为 OBR。



#### （四）OBR是OS Boot Record 操作系统引导记录

OBR位于活动扇区最开始的扇区，也就是第一个扇区，这个扇区称为OBR引导扇区。在这个扇区中，有1样东西：

* 3字节的跳转指令



#### （五）想要理解清楚它们之间的关系需要从BIOS开始

BIOS是嵌在主板上的基本输入输出系统。它的内存很小，不可能实现操作系统的工作，你让BIOS运行一个QQ，它肯定是完成不了的。

所以BIOS需要将CPU控制权进行转交。因为BIOS在上电后拥有CPU的控制权，所以它将MBR引导扇区中的引导程序放到物理地址0x7c00处，然后跳到0x7c00去执行引导程序的代码。**这就好像是BIOS将CPU的控制权从自己手中转交到了MBR手中**。

我们前面说过MBR引导扇区中还有64字节的分区表，分区表里面存储了各分区的信息。每个分区表项是16字节的，因此分区表中可以记载4个分区的消息，这4个分区中都可能被安装了操作系统，如果某个分区被安装了操作系统的话，那么MBR中的分区表对应的4个分区的分区表项中”活动分区“项被赋值为0x80，操作系统会在该分区中提供引导程序，这个分区中的引导程序的位置和MBR一样，都是第一个扇区，在第一个扇区中存放操作系统的引导程序，这个引导程序通常是内核加载器，这个扇区被称为<font color=red>操作系统引导扇区</font>,其中的操作系统引导程序（内核加载器）被称为操作系统引导记录OS Boot Record，此扇区也称为<font color=red>OBR引导扇区</font>。

OBR引导扇区中，有1样东西：

* 3个字节的跳转指令

MBR在获取到CPU的控制权之后，开始遍历这4个分区的信息，当有一个分区表项的”活动分区“为0x80时，MBR就将CPU的控制权交给这个分区上的引导程序。这就好像是**MBR将CPU的控制权交给了活动分区**。

 活动分区中OBR引导扇区的跳转指令会跳转到操作系统引导程序，**活动分区将CPU控制权交给了操作系统内核**。

3个字节的跳转指令的目标地址不是固定的，这是由所创建的文件系统决定的，对于 FAT32文件系统来说，此跳转指令会跳转到本扇区偏移 0x5A 字节的操作系统引导程序处。不管跳转目标地址是多少，那里通常是操作系统的内核加载器。



总结：

BIOS将MBR引导扇区的引导程序加载到物理地址0x7c00处执行。**CPU控制权转交给了MBR**。

MBR 找到活动分区后，就跳到活动分区的OBR 引导扇区的起始处。**CPU控制权转交给了活动扇区**。

OBR引导扇区起始处的跳转指令跳转到目标地址，那么目标地址处是操作系统引导程序。**CPU控制权转交给了操作系统内核**。

从此完成了CPU的交接工作，以后便是内核的天下了。

