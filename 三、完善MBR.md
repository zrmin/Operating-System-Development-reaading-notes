<h1><center>完善MBR</center></h1>

## 一、地址、section、vstart

#### （一）什么是地址

编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。

地址 = 前一个指令的地址+前一个指令的大小。

上图为证：

![image-20220502175311459](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205021753535.png)

图中，很明显：$一个指令的地址 = 上一个指令的地址 + 上一个指令的大小$



#### （二）什么是section

编译器提供的关键字 Section 只是为了让程序员在逻辑上将程序划分成几个部分。

![image-20220502200431947](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022004048.png)

关键字 section 并没有对程序中的地址产生任何影响，即在默认情况下，有没有 section 都一个样，section 中数据的地址依然是相对于整个文件的顺延，仅仅是在逻辑上让开发人员梳理程序之用。



#### （三）什么是vstart

vstart 的作用是为 section 内的数据指定一个虚拟的起始地址，也就是根据此地址，在文件中是找不到相关数据的，是虚拟的，假的，文件中的所有符号都不在这个地址上。

![image-20220502200727460](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022007501.png)

大概意思是 section 用 vstart=来修饰后，可以被赋予一个虚拟起始地址 virtual start address（强调了这个是虚拟的地址，不过要注意，这与 x86 CPU 中开启分页后的虚拟地址是两码事，不能混为一谈），它被用来计算在该 section 内的所有内存引用地址。

地址访问策略是根据程序中给出的地址，到地址处去拿东西，所以这个东西要提前在那个地址处准备好了才行，这是永恒不变的。程序中给出的地址，最终是要用来访问物理内存的，所以该地址对应的物理内存必须是你想要的才行，换句话说，必须保证自己想要的东西被加载到那个物理内存位置。这就是程序加载器做的事，根据文件头中给出的各段的位置，将它们加载到内存中的相应地址，这样用户程序才能访问到自己需要的东西。

![image-20220502203938978](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022039050.png)

**这里有一个大家常见的陷阱**：vstart=xxxx 和 org xxxx 这两个关键字是同一功能，但很多人都混淆其意义。它们并不是告诉编译器把程序加载到地址 xxxx，这似乎一听，好像是编译器有加载器的功能了，“加载”不是编译器的工作，这是加载器的工作，编译器只会规划代码——只会为程序编址，并不负责加载。

正确的理解是：vstart 和 org，它们的功能是告诉编译器：“你把我后面所有数据（指令和变量）的地址以 xxxx 为起始地址进行编址”。

只有开发人员知道以xxxx 为起始地址的原因是将来有某个加载器要把我的这个程序放到内存的 xxxx 地址，如果我程序中引用的所有地址不是以 xxxx 为起始的，那就会访问错误的数据。但编译器并不知道这些，它会帮你按照vstart=xxxx这个起始地址，对本section中的指令、数据进行编址。

所以说，用 vstart 的时机是：我预先知道我的程序将来被加载到某地址处。程序只有加载到非 0 地址时 vstart 才是有用的，程序默认起始地址是 0。

编译器只负责编址，它只会将数据相对于文件开头的偏移量作为该数据的地址，全是以0 起始的。编译器以相对于文件开头偏移来编址的好处是利于重定位。整个文件新加载到某个地址后，可以以这个地址为段基址，文件内的数据的地址是以 0 为开始算的，所以它们直接就可以用作段内偏移地址了。

vstart 只是告诉编译器以新的数字作为后面数据的地址的起始值，它本身没改变数据本身在文件中的地址（相对于文件开头的偏移）。

就像我们前面编写的MBR代码一样。mbr 用 vstart=0x7c00 来修饰的原因，是因为开发人员知道 mbr 要被加载器（BIOS）加载到物理地址0x7c00，mbr 中后续的物理地址都是 0x7c00+。另外，因为 BIOS 进入 mbr 是通过 jmp 0：7c00 来实现的，故此时 cs 已经变成 0，相当于“平坦模型”了，只不过此“平坦模型”大小只是$2^{16}$字节，而不是 4GB。所以 mbr 中各数据编译出来的地址（大于等于 0x7c00）实际上都成了偏移地址，这样`0*16：偏移地址0x7c00+`来访问被加载到 0x7c00 的 mbr 是正确无误的。



## 二、CPU实模式

实模式是指 8086 CPU 的寻址方式、寄存器大小、指令用法等，是用来反应 CPU 在该环境下如何工作的概念。

所以想了解实模式这种抽象的概念，主要就是了解在实模式下 CPU 能做什么。

#### （一）CPU的工作原理

至于为什么要讲一下CPU的工作原理，是因为无论CPU在哪种模式下工作，工作原理都是不变的。

具体的原理《ics》和其他的一些书上都有，简要总结一下：

<i>控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs：ip。于是读取 ip 寄存器后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中。这时候轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程。操作码有了，操作数也齐了，操作控制器给运算单元发送控制信号，于是运算单元便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址。接着控制单元又要取下一条指令了，流程回到了本段开头，CPU周而复始。</i>



CPU 大体上可以划分为 3 个部分：

1. 控制单元：控制单元是 CPU 的控制中心，CPU 需要经过它的帮忙才知道自己下一步要做什么。而控制单元大致由指令寄存器 IR（Instruction Register）、指令译码器 ID（Instruction Decoder）、操作控制器 OC（Operation Controller）组成。
2. 运算单元
3. 存储单元：存储单元是指 CPU 内部的 L1、L2 缓存及寄存器，操作数就存放在这些存储单元中



程序被加载到内存后，也就是指令这时都在内存中了，指令指针寄存器 IP 指向内存中下一条待执行指令的地址，控制单元根据 IP 寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中，但它还是不知道这些指令是什么，在它眼里的 0101 串此时还没有实际意义。然后指令译码器将位于指令寄存器中的指令按照指令格式来解码，分析出操作码是什么，操作数在哪里之类的。

IA32的指令格式如下：

| 前缀 | 操作码 | 寻址方式、操作数类型 | 立即数 | 偏移量 |
| :--: | :----: | :------------------: | :----: | :----: |

* 前缀：由于 intel CPU 支持的指令数量较多，一些指令还可以搭配一些辅助的功能，所以就需要在前缀部分记录。如 rep（用于重复执行，汇编中经常用）、段超越前缀。

* 操作码：操作码就是大家平时用的 mov、jmp 等
* 寻址方式、操作数类型：寻址方式又有好多，如基址寻址、变址寻址等，操作数类型中记录的是用哪些寄存器之类的
* 立即数：如果在指令中用到了立即数，就要将其记录到指令格式中立即数的部分
* 偏移量：如果寻址方式中用到了偏移量，就要将此偏移量记录到指令格式中的偏移量部分



寄存器可分为两大类，程序员可以使用的寄存器称为程序可见寄存器，如通用寄存器、段寄存器。程序不可见寄存器是指程序员不可使用，也无法访问到它们，系统运行期间可能要用到的寄存器，如 ALU 算术逻辑单元在求和时，会将结果先送到数据暂存寄存器。



#### （二）实模式下的寄存器

CPU中的寄存器分为两类：（这种划分方法和老大的有些不一样）

1. 不可见寄存器，也就是对程序员不能使用。
   * 全局描述符表寄存器 GDTR
   * 中断描述符表寄存器 IDTR
   * 局部描述符表寄存器 LDTR
   * 任务寄存器 TR
   * 控制寄存器 CR0～3
   * 指令指针寄存器 IP
   * 标志寄存器 flags
   * 调试寄存器 DR0～7
2. 可见寄存器，我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器。

![image-20220502211918141](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119985.png)

在 16 位 CPU 中，只有一个附加段寄存器—ES。而FS 和 GS 附加段寄存器是在 32 位CPU 中增加的。我们使用的是 32 位 CPU，并不是说 32 位 CPU 在实模式下的 16 位环境中就不能用 FS 和GS 寄存器。32 位的 CPU 兼容 16 位 CPU 的特性。



![image-20220502211942142](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119965.png)

在执行当前指令的同时，在不跨段的情况下，CPU 以“当前 IP 寄存器中的值+当前执行指令的机器码长度”的和作为新的代码段内偏移地址，将其存入 IP 寄存器，再到该新地址处读取指令并执行。如果下一条指令需要跨段访问，还要加载新的段基址到CS 段寄存器。

![image-20220502211959036](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119861.png)

flags寄存器：任何一个指令的执行、其执行过程的细节、对计算机造成了哪些影响，都在 flags 寄存器中通过一些标志位反映出来



通用寄存器：

无论是实模式，还是保护模式，通用寄存器有 8 个，分别是 AX、BX、CX、DX、SI、DI、BP、SP

![image-20220502212516058](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022125101.png)

在32位CPU，AX、BX、CX、DX被扩展成32位，变成了EAX、EBX、ECX、EDX，这里提及了寄存器 eax等 的原因是在实模式下虽然操作数是 16 位，但依然可以用 32 位的寄存器，因为我们所讲的是 32 位 CPU 在实模式下的工作状态，并不是纯粹的8086这样的16位CPU。

| 寄存器 |              助记名称               |                           功能描述                           |
| :----: | :---------------------------------: | :----------------------------------------------------------: |
|   ax   |        累加器（accumulator）        | 使用频度最高，常用于算术运算、逻辑运算、保存与外设输入输出的数据 |
|   bx   |         基址寄存器（base）          |  常用来存储内存地址，用此地址作为基址，用来遍历一片内存区域  |
|   cx   |          计数器（counter）          | 顾名思义，计数器的作用就是计数，所以常用于循环指令中的循环次数 |
|   dx   |         数据寄存器（data）          |  可用于存放数据，通常情况下只用于保存外设控制器的端口号地址  |
|   si   |    源变址寄存器（source index）     | 常用于字符串操作中的数据源地址，即被传送的数据在哪里。通常需要与其他指令配合使用，如批量数据传送指令族 movs[bwd] |
|   di   | 目的变址寄存器（destination index） | 和 si 一样，常用于字符串操作。但 di 是用于数据的目的地址，即数据被传送到哪里 |
|   sp   |    栈指针寄存器（stack pointer）    | 其段基址是 SS，用来指向栈顶。随着栈中数据的进出，push 和 pop 这两个对栈操作的指令会修改 sp 的值 |
|   bp   |      基址指针（base pointer）       | 访问栈有两种方式，一种是用 push 和 pop 指令操作栈，sp 指针的值会自动更新，但我 |

bp: 访问栈有两种方式，一种是用 push 和 pop 指令操作栈，sp 指针的值会自动更新，但我们只能获取栈顶 sp 指针指向的数据。很多时候，我们需要读写在栈底和栈顶之间的数据，处理器为了让开发人员方便控制栈中数据，还提供了把栈当成数据段来访问的方式，即提供了寄存器 bp，所以 bp 默认的段寄存器就是 SS，可通过 SS：bp 的方式把栈当成普通的数据段来访问，只不过 bp 不像 sp 那样随 push、pop 自动改变



#### （三）实模式下内存分段的由来

在8086CPU之前，内存访问直接使用真实的物理内存地址，也就是硬编码的形式。这样做不方便程序重定位。也就是说当两个程序所用到的内存有冲突时，另一个程序需要等待之前的程序退出运行后才能运行。为了解决这个问题，intel的工程师提出了“段”的概念，这样程序就可以重定位了。

可是8086 CPU中的寄存器是16位的，8086的地址线是20位的，16位的CPU能够访问$2^{16} = 64KB$大小的内存空间，但是20位的地址总线是$2^{20}=1MB$的内存空间。那么如何让16位的寄存器可以访问1MB的内存地址空间就成了一个问题。

intel工程师提出的解决方法是，将段基址寄存器中的地址左移4位，然后与偏移量相加，这样就可以地址就是20位的了。

可是我们虽然解决了这个问题，但是又出现了另外一个问题：

$0xFFFF:0XFFFF = 0xFFFF0 + 0xFFFF = 0xFFFFF + 0xFFF0 $

$= 16^5 + 0xFFFF - 0x000F$

$ = 2^{20} + 16^4 - 16$ 

$= 1MB + 2^{16} - 16$ 

$= 1MB + 64KB - 16$

也就是收使用段基址：段内偏移量的方式来访问内存，反而还多出来64KB - 16B的字节，这多出来的内存就是我们经常说的`高端内存`HMA：high memory area。

那么如何处理呢——不处理。

因为地址线是20位，即A0-A19，当访问的内存超出1MB时，A0-A19这20根地址线就不够了，需要额外用一根A20地址线。但是由于8086没有A20地址线，所以向A20的地址进位被舍掉了。因此，超出1MB地址范围的地址，相当于是对1MB取模了，将会从头开始访问。这就是`地址回卷`wrap-around。

![image-20220503003220018](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205030032192.png)

通过这部分我们引出了从实模式到保护模式需要打开A20地址线的问题，这个我们进入保护模式后再谈。



#### （四）实模式下CPU内存寻址方式

要找了解寻址方式，首先就得知道什么是寻址？寻址就是寻找地址，寻找谁的地址呢？——寻找数的地址，这个数既可以是源操作数，也可以是目的操作数。

![实模式下的寻址方式](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205031619632.jpg)



#### （五）栈到底是什么玩意儿

CPU中有SS和SP、BP3个和栈有关的寄存器。也就是说，CPU想要正常运行，必须要有栈才行。

栈是向下发展的，但栈也是内存，访问内存依然是从低地址往高地址，假如当前栈顶是 0x1233E，栈顶数据占 2 字节的话，其范围是 0x1233E～0x1233F。



#### （六）实模式下的ret

在调用函数时，是使用call指令，call在调用时，会将返回地址保存在栈中。我们知道x86中，地址是由CS:IP寄存器负责的，那么栈顶保存的是CS寄存器中的内容，还是IP寄存器中的内容呢？

这主要取决于被调用的函数的地址是否和主调函数的段基址相同，如果没有跨段访问的话，只需要保存IP寄存器中的值；相反，如果跨段访问了，那么还需要将CS段寄存器的值也保存下来。

当被调函数执行完成后，需要调用ret或者retf指令来返回。

ret指令是近返回指令，它将栈顶的2字节返回地址压入IP寄存器中，然后将栈顶指针SP+2。

retf指令是远返回指令（return far），它将栈顶的4字节的CS和IP寄存器的值压入CS:IP寄存器中，并使栈顶指针SP+4。



#### （七）实模式下的call

在 8086 处理器中，有两个指令用于改变程序流程。一个是 jmp，另一个是 call。

它们的区别是 jmp属于一去不回头地去执行新的代码，适用环境是“交接”，如我们的 BIOS 将接力棒交给 MBR，之后再也用不到 BIOS 其余的代码。程序中有执行主线时，call 指令用于执行完一段分支后再回来的情况，当然它能回来还是需要用 ret 或 retf 来配合。

在 8086 处理器中，也就是我们所说的实模式下，call 指令调用函数有四种方式：

1. 2种近调用
2. 2种远调用

进调用就是指要调用的函数和主调函数在同一个段内，因为段寄存器是16位宽，也就是说，和主调函数在上下64KB之内。

CPU默认是近调用，即`call near 立即数地址`，near可以省略，因为CPU默认是near。指令中的立即数地址可以是被调用的函数名、标号、立即数，函数名同标号一样，它只是地址的人性化表示方法，最终会被编译器转换为一个实际数字地址。



我们实际上只用前两种近调用的方式来使用call：

* call 相对近调用发生时，CPU 将当前 IP 寄存器值压入栈，再把上面计算出的绝对地址载入 IP 寄存器，CPU 的航线立马被改变到目标地址处
* 16 位实模式间接绝对近调用
* 16 位实模式直接绝对远调用
  * `call far 段基址（立即数）：段内偏移地址（立即数）`
* 16 位实模式间接绝对远调用
  * `call far 内存寻址`



#### （八）实模式下的jmp

1. 短转移
2. 近转移
3. 远转移

* 16 位实模式相对短转移
  * jmp short 立即数地址
  * jmp $
* 16 位实模式相对近转移
  * jmp near 立即数地址
* 16 位实模式间接绝对近转移
  *  jmp near 寄存器寻址，或者 jmp near 内存寻址
  * 若操作数在内存中，在不使用段跨越前缀的情况下，段基址寄存器是 DS
* 16 位实模式直接绝对远转移
  * jmp 立即数形式的段基址：立即数形式的段内偏移地址
* 16 位实模式间接绝对远转移
  * jmp far 内存寻址
  * 由于操作数在内存中，在不使用段跨越前缀的情况下，段基址寄存器是 DS



#### （九）标志寄存器flag

![image-20220503202744755](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032027879.png)

第 0 位的是 CF 位，即 Carry Flag，意为进位。运算中，数值的最高位有可能是进位，也有可能是借位，所以 carry 表示这两种状态。不管最高位是进位，还是借位，CF 位都会置 1，否则为 0。它可用于检测无符号数加减法是否有溢出，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。

第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位 为 1，否则为 0。注意啦，是最低的那 8 位，不管操作数是 16 位，还是 32 位。奇偶校验经常用于数据传输开始时和结束后的对比，判断传输过程中是否出现错误。

第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。 

第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。 

第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。

第8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。平时我们用的 debug 程序，在单步调试时，原理上就是让 TF 位为 1。可见，软件上的很多功能，必须有硬件的原生支持才能得以实现。

第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的，因为它关不住。

第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为 1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。其中提到的这个单位的大小，取决于用什么指令。

第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。用来标识计算的结果是否超过了数据类型可表示的范围，若超出了范围，就像水从锅里溢出去了一样。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测有符号数运算结果是否有溢出现象。

第 12～13 位为 IOPL，即 Input Output Privilege Level，这用在有特权级概念的 CPU 中。有 4 个任务特权级，即特权级 0、特权级 1、特权级 2 和特权级 3。故 IOPL 要占用 2 位来表示这 4 种特权级。

第 14 位为 NT，即 Nest Task，意为任务嵌套标志位。8088 支持多任务，一个任务就是一个进程。当一个任务中又嵌套调用了另一个任务（进程）时，此 NT 位为 1，否则为 0。

第 16 位为 RF 位，即 Resume Flag，意即恢复标志位。该标志位用于程序调试，指示是否接受调试故障，它需要与调试寄存器一起使用。当 RF 为 1 时忽略调试故障，为 0 时接受。

第 17 位为 VM 位，即 Virtual 8086 Model，意为虚拟 8086 模式。这是实模式向保护模式过渡时的产物，现在已经没有了。CPU 有了保护模式后，功能更加强大了，但为了兼容实模式下的用户程序，允许将此位置为 1，这样便可以在保护模式下运行实模式下的程序了。实模式下的程序不支持多任务，而且程序中的地址就是真实的物理地址。所以在保护模式下每运行一个实模式下的程序，就要为其虚拟一个实模式环境，故称为虚拟模式。

第 18 位为 AC 位，即 Alignment Check，意为对齐检查。什么是对齐呢？是指程序中的数据或指令其内存地址是否是偶数，是否是 16、32 的整数倍，没有余数，这样硬件每次对地址以自增地方式（每次自加 2、16、32 等）访问内存时，自增后的地址正好对齐数据所在的起始地址上，这就是对齐的原理。对齐并不是软件逻辑中的要求，而是硬件上的偏好，如果待访问的内存地址是 16 或 32 的整数倍，硬件上好处理，所以运行较快。若 AC 位为 1 时，则进行地址对齐检查，为 0 时不检查。

第 19 位为 VIF 位，即 Virtual Interrupt Flag，意为虚拟中断标志位，虚拟模式下的中断标志。

第 20 位为 VIP 位，即 Virtual Interrupt Pending，意为虚拟中断挂起标志位。在多任务情况下，为操作

系统提供的虚拟中断挂起信息，需要与 VIF 位配合。

第 21 位为 ID 位，即 Identification，意思为识别标志位。系统经常要判断 CPU 型号，若 ID 为 1，表示当前 CPU 支持 CPU id 指令，这样便能获取 CPU 的型号、厂商等信息。若 ID 为 0，则表示当前 CPU 不支持 CPU id 指令。



#### （十）有条件转移

格式：`jxx 目标地址`  (jne、je、jnle……)。

![image-20220503204729268](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032047390.png)

| 字母 |   含义   |
| :--: | :------: |
|  a   |  above   |
|  b   |  below   |
|  c   |  carry   |
|  e   |  equal   |
|  g   |  great   |
|  j   |   jmp    |
|  l   |   less   |
|  n   |   not    |
|  o   | overflow |
|  p   |  parity  |



#### （十一）实模式小结





## 三、让我们直接对显示器说点什么吧

之前我们实现了简单的MBR程序，用它打印了“My MBR”字符串，我们用的是 BIOS 提供的 0x10 中断来实现的滚屏和打印字符。那么现在，是时候利用显卡来在屏幕上输出信息了。

#### （一）CPU如何与外设通信——IO接口

IO 接口的功能：

1．设置数据缓冲，解决 CPU 与外设的速度不匹配。CPU 和外设速度上的差异可以通过设置缓冲区来解决，也就是说，数据先存储在缓冲区里，等需要的时候（无论缓冲区是否满了）就传送出去。

2．设置信号电平转换电路。CPU 和外设的信号电平不同，如 CPU 所用的信号是 TTL 电平，而外设大多数是机电设备，故不能使用 TTL 电平驱动，可以在接口电路中设置电平转换电路来解决。

3．设置数据格式转换。外设是多种多样的，输出的信息可能是数字信号、模拟信号等，而 CPU 只能处理数字信号。数字信号需要经过数/模转换（D/A）成模拟量才能被送到外设以驱动硬件，模拟量也同样需要经过模/数（A/D）转换成数字量才能被 CPU 处理。所以接口电路中需要包括 A/D 转换器和 D/A 转换器。另外，即使双方使用的都是数字信号，这也牵涉到格式和字长的问题，如 CPU 使用的是 8 位、16 位或 32 位并行数据，而外设使用并行或串行数据都有可能，所以 IO 接口中必须能够识别格式并且转换成对方需要的形式才行。

4．设置时序控制电路来同步 CPU 和外部设备。硬件的工作也按照某种时序，它们都有自己的时序系统，就像 CPU 工作在自己的晶振时序上一样。双方时序不同，接口电路就要协调这两种不同的时间计法。例如，CPU 发控制信号、定时信号给 IO 接口电路，IO 接口用它们来控制和管理硬件。随后硬件有了反馈后，其应答信号也需要通过接口返回给 CPU，这样 CPU 先“问”，硬件后“回答”，就实现了一次握手，之后便可以实现 IO 的同步操作。

5．提供地址译码。CPU 同多个硬件打交道，每个硬件要反馈的信息很多，所以一个 IO 接口必须包含多个端口，即 IO接口上的寄存器，来存储这些信息内容。但同一时刻，只能有一个端口和 CPU 数据交换，这就需要 IO 接口提供地址译码电路，使 CPU 可以选中某个端口，使其可以访问数据总线。

![image-20220503211542778](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032115835.png)

IO 接口通过内部专用于数据交互的寄存器同 CPU 通信，为了区别于 CPU 内部的寄存器，IO 接口中的寄存器就称为端口。

如何访问到端口呢？IA32 体系系统中，由于用的是Isolated IO独立编址而不是memory-mapped IO，所以就不能把它当作内存来操作，因此 CPU 提供了专门的指令来干这事，`in`和`out`。

Intel 汇编语言的形式是：操作码目的操作数，源操作数。Intel 采用这种格式的原因可能是觉得这样表达“目的操作数”=“源操作数”更形象，如同 a=6 这种形式。

1. in 指令用于从端口中读取数据，其一般形式是：

（1）in al, dx； 

（2）in ax, dx。

其中 al 和 ax 用来存储从端口获取的数据，dx 是指端口号。

这是固定用法，只要用 in 指令，源操作数（端口号）必须是 dx，而目的操作数是用 al，还是 ax，取决于 dx 端口指代的寄存器是 8 位宽度，还是 16 位宽度。

2. out 指令用于往端口中写数据，其一般形式是：

（1）out dx, al； 

（2）out dx,ax； 

（3）out 立即数, al； 

（4）out 立即数, ax

<i>注意：</i>

<i>in 指令中，端口号只能用 dx 寄存器。</i>

<i>out 指令中，可以选用 dx 寄存器或立即数充当端口号</i>



#### （二）显卡概述

mbr 运行在实模式下，所以在实模式下可以用 BIOS 的 0x10 中断打印字符串，这是因为：首先中断向量表只在实模式下存在，BIOS 中断是要依赖于中断向量表的。可是，接下来进入保护模式后，保护模式下就没有中断向量表了，所以也就无法用 BIOS 中断向屏幕输出信息了。因此，我们要通过直接操作显卡来向屏幕打印信息。

某些 IO 接口也叫适配器，适配器是驱动某一外部设备的功能模块。显卡也称为显示适配器，不过归根结底它就是 IO 接口，专门用来连接 CPU 和显示器。我们想操作显示器，没有直接的办法，只能通过它的 IO 接口—显卡。

之以后我们的输出都是通过直接操作显卡来实现的，而显卡给我们的输入接口是显存和端口，我们主要用的是显存。显存作为接口，说白了，就是它把显存直接给我们用，说：“把你要输出的内容写到这里面，我照着往屏幕上打印”。



#### （三）显存、显卡、显示器

显存是由显卡提供的，它是位于显卡内部的一块内存，所以它称为显存。显卡的工作就是不断地读取这块内存，随后将其内容发送到显示器。

<center><h5>显存地址分布</h5></center>

| 起始地址 | 结束地址 | 大小 |          用途          |
| :------: | :------: | :--: | :--------------------: |
|  C0000   |  C7FFF   | 32KB |     显示适配器BIOS     |
|  B8000   |  BFFFF   | 32KB | 用于文本模式显示适配器 |
|  B0000   |  B7FFFF  | 32KB |   用于黑白显示适配器   |
|  A0000   |  AFFFF   | 64KB |   用于彩色显示适配器   |

显卡支持三种模式：

1. 文本模式。从起始地址 0xB8000 到 0xBFFFF，这片 32KB 大小的内存区域是用于文本显示。我们往 0xB8000处输出的字符直接会落到显存中，显存中有了数据，显卡就会将其搬到显示器屏幕上了
2. 黑白图形模式
3. 彩色图形模式

我们只关注文本模式就好了，最终我们要实现类似 Linux 终端那样的字符界面。

不同的文本模式在屏幕上可以打印出的字符数量是不一样的。显卡在加电后，默认就置为模式 80*25，1行有80个字符，总共是25行，也就是一屏可以打印 2000 个字符。每个字符在屏幕上都是由 2 个连续的字节来表示的。

每个字符的低字节是字符的 ASCII 码，高字节是字符属性元信息。在高字节中，低 4 位是字符前景色，高 4 位是字符的背景色。颜色用 RGB 红绿蓝三种基色调和，第 4 位用来控制亮度，若置 1 则呈高亮，若为 0 则为一般正常亮度值。第 7 位用来控制字符是否闪烁（不是背景闪烁）。

![image-20220503215710164](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032157230.png)



![image-20220503215845786](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032158885.png)



#### （四）改进MBR，直接操作显卡

对我们之前的mbr.S代码进行改进，将里面使用BIOS中断方法进行打印的方法替换成直接操作显卡的方法：

```assembly
;主引导程序
;---------------------

SECTION MBR vstart=0x7c00 ;程序开始的地址
    mov ax, cs            ;使用cs初始化其他的寄存器
    mov ds, ax            ;因为是通过jmp 0:0x7c00到的MBR开始地址
    mov es, ax            ;所以此时的cs为0,也就是用0初始化其他寄存器
    mov ss, ax            ;此类的寄存器不同通过立即数赋值，采用ax中转
    mov fs, ax
    mov sp, 0x7c00  ;初始化栈指针
    mov ax, 0xb800  ;段基址需要左移4位，所以用0xb800，而不是0xb8000
    mov gs, ax      ;段寄存器不能直接赋值，所以用ax中转一下

;清屏利用0x10中断的0x6号功能
;------------------------
    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f

    int 0x10

; 输出背景色绿色，前景色红色，并且跳动的字符串“My MBR"
    mov byte [gs:0x00],'M'
    mov byte [gs:0x01],0xA4 ;A表示绿色背景闪烁，4表示前景色红色

    mov byte [gs:0x02], 'y'
    mov byte [gs:0x03], 0xA4

    mov byte [gs:0x04], 'M'
    mov byte [gs:0x05], 0xA4

    mov byte [gs:0x06], 'B'
    mov byte [gs:0x07], 0xA4

    mov byte [gs:0x08], 'R'
    mov byte [gs:0x09], 0xA4

    jmp $

    message db "My MBR"
    times 510-($-$$) db 0 
    db 0x55, 0xaa

```

```shell
nasm -o mbr.bin mbr.S
```

```shell
sudo dd if=mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc
```

```shell
sudo bin/bochs -f bochsrc.disk
```

启动bochs后：

![image-20220503230103941](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032301099.png)

由上图看出，确实是闪烁的“MyMBR“字符串。左面是字符串闪烁没了，右边是字符串闪烁出来了。



## 四、bochs调试方法

bochs 是一个开源 x86 虚拟机软件。在它的实现中定义了各种数据结构来模拟硬件。

bochs 的硬件调试体现在：

（1）调试时可以查看页表、gdt、idt 等数据结构

（2）可以查看栈中数据

（3）可以反汇编任意内存

（4）实模式、保护模式互相变换时提醒

（5）中断发生时提醒

#### （一）bochs一般用法

在bochs中输入help后：

![image-20220503231101060](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205032311137.png)

可见，bochs的调试命令分为下面4类：

1. Debugger control
2. Execution control
3. Breakpoint management
4. CPU and memory contents



## 五、硬盘介绍

#### （一）硬盘发展简史



#### （二）硬盘工作原理

磁头臂移动到目标位置的时间称为寻道时间

CPU 是怎样和硬盘打交道的呢?换句话说，针对硬盘的 IO 接口是什么？答案就是硬盘控制器。



#### （三）硬盘控制器端口

让硬盘工作，我们需要通过读写硬盘控制器的端口，端口就是位于 IO 控制器上的寄存器，此处的端口是指硬盘控制器上的寄存器。

![image-20220504132315974](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205041323133.png)

1. data 寄存器：负责管理数据，其作用是读取或写入数据。data寄存器是16bit的，表中其他寄存器都是 8 位的。

* 在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据
* 在写硬盘时，我们要把数据写入这个端口，数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中

2. Error寄存器：读硬盘时，端口 0x171 或 0x1F1 的寄存器名字叫 Error 寄存器，只在读取硬盘失败时有用，里面才会记录失败的信息，尚未读取的扇区数在 Sector count 寄存器中。

3. Feature寄存器：在写硬盘时，此寄存器有了别的用途，所以有了新的名字，叫 Feature 寄存器。有些命令需要指定额外参数，这些参数就写在 Fea ture 寄存器中。

4. Command寄存器：在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。

   我们只用到3个命令：

   * identify：0xEC，即硬盘识别
   * read sector：0x20，即读扇区
   * write sector：0x30，即写扇区

   总结：

   Error寄存器和Feature寄存器，Status寄存器和Command寄存器：

* 这两组都是同一寄存器（也就是同一端口）多个用途
* 对同一端口写操作时，硬盘控制器认为这是个命令
* 对同一端口读操作时，硬盘控制器认为是想获得状态。

![image-20220504134546353](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205041345438.png)

device 寄存器是个杂项，它的宽度是 8 位。在此寄存器的低 4 位用来存储 LBA 地址的第 24～27 位。结合上面的三个 LBA 寄存器。第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。另外的两位：第 5 位和第 7 位是固定为 1 的，称为 MBS 位。

![image-20220504134621904](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205041346972.png)

在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错了，具体原因可见 error 寄存器。第 3 位是 data request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来。第 6 位是 DRDY，表示硬盘就绪，此位是在对硬盘诊断时用的，表示硬盘检测正常，可以继续执行一些命令。第 7 位是 BSY位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙着，此寄存器中的其他位都无效。



#### （四）常用的硬盘操作方法

1. 硬盘操作基本顺序

   * 先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数
   * 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位
   * 往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4位，选择操作的硬盘（master 硬盘或 slave 硬盘）
   * 往该通道上的 command 寄存器写入操作命令
   * 读取该通道上的 status 寄存器，判断硬盘工作是否完成
   * 如果以上步骤是读硬盘，进入下一个步骤。否则，完工
   * 将硬盘数据读出

2. 硬盘工作完成后，它已经准备好了数据，咱们该怎么获取呢？一般常用的数据传送方式如下

   * 无条件传送方式：
     * 应用此方式的数据源设备一定是随时准备好了数据，CPU 随时取随时拿都没问题，如寄存器、内存就是类似这样的设备，CPU 取数据时不用提前打招呼

   * **查询传送方式**
     * 程序 I/O、PIO（Programming Input/Output Model）
     * 轮询设备是否准备好了数据，准备好了就取数据

   * **中断传送方式**

     * 中断驱动IO

     * 不轮询，设备准备好数据后向CPU发送中断

   * 直接存储器存取方式（DMA）

     * 数据源设备和内存直接传输。CPU 直接到内存中拿数据
     * 过 DMA 是由硬件实现的，不是软件概念，所以需要 DMA 控制器

   * I/O 处理机传送方式

     * I/O 处理机——专门用于处理 IO。它是一种处理器，用的是另一套擅长 IO 的指令系统，随时可以处理数据

       

3.  我们使用的可编程IO和中断驱动IO。



## 六、让MBR使用硬盘

此前，我们的MBR从BIOS手中接下了CPU控制权的交接棒，但是MBR只有512字节，干不了什么大事，所以MBR迟早要将CPU的控制权交出去，那么MBR应该把控制权交给谁呢？我们接下来揭晓。

#### （一）改造MBR

我们的 MBR 受限于 512 字节大小的，在那么小的空间中，没法为内核准备好环境，更没法将内核成功加载到内存并运行。所以我们要在另一个程序中完成初始化环境及加载内核的任务，这个程序我们称之为 loader，即加载器。Loader 会在下一节中实现。问题来了，loader 在哪里？如何跳过去执行？这就是新款 MBR 的使命，简而言之就是，**负责从硬盘上把 loader 加载到内存，并将接力棒交给它**。

操作硬盘：命令号赋值给ax，端口号赋值给dx

nasm宏定义语法：`宏名 equ 值`

```assembly
; boot.inc文件，放到include目录下
; loader和kernel
LOADER_BASE_ADDR equ 0x900 ; 定义了 loader 在内存中的位置，MBR 要把 loader 从硬盘读入后放到此处
LOADER_START_SECTOR equ 0x2 ; 定义了 loader 在硬盘上的逻辑扇区地址，即 LBA 地址：loader 放在第 2 块扇区
```

`%include` 是 nasm 编译器中的预处理指令，意思是让编译器在编译之前把 boot.inc 文件包含进来。

4-48行和之前的版本一样。

```assembly
;主引导程序
;------------------------------------------------------------ 
%include "boot.inc" 
SECTION MBR vstart=0x7c00 
mov ax,cs 
mov ds,ax 
mov es,ax 
mov ss,ax 
mov fs,ax 
mov sp,0x7c00 
mov ax,0xb800 
mov gs,ax 

;清屏
;利用 0x06 号功能，上卷全部行，则可清屏
; ----------------------------------------------------------- 
;INT 0x10 功能号：0x06 功能描述：上卷窗口
;------------------------------------------------------ 
;输入：
;AH 功能号= 0x06 
;AL = 上卷的行数（如果为 0，表示全部）
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
 ;无返回值：
mov ax, 0600h 
mov bx, 0700h 
mov cx, 0 ; 左上角: (0, 0) 
mov dx, 184fh ; 右下角: (80,25), 
; 因为 VGA 文本模式中，一行只能容纳 80 个字符，共 25 行
; 下标从 0 开始，所以 0x18=24，0x4f=79 
int 10h ; int 10h 

; 输出字符串:MBR 
mov byte [gs:0x00],'1' 
mov byte [gs:0x01],0xA4 

mov byte [gs:0x02],' ' 
mov byte [gs:0x03],0xA4 

mov byte [gs:0x04],'M' 
mov byte [gs:0x05],0xA4 
;A 表示绿色背景闪烁,4 表示前景色为红色

mov byte [gs:0x06],'B' 
mov byte [gs:0x07],0xA4 

mov byte [gs:0x08],'R' 
mov byte [gs:0x09],0xA4 
; 第 50～52 行为函数 rd_disk_m_16 传递参数:选择用 eax、bx、cx 寄存器来传递参数
mov eax,LOADER_START_SECTOR ; 待读入的扇区起始地址。起始扇区 lba 地址
mov bx,LOADER_BASE_ADDR ; 写入的地址：数据从硬盘读进来后放在内存中哪里呢
mov cx,1 ; 待读入的扇区数
call rd_disk_m_16 ; 以下读取程序的起始部分(一个扇区) read_disk_mode_16:在16位模式下读硬盘

jmp LOADER_BASE_ADDR ; 这里是 MBR 交出接力棒的一刻，采用jmp 是唯一合适的选择。Jmp 的操作数是 LOADER_BASE_ADDR，即 0x900，这是要跳到内核加载器的节奏。MBR 到此结束了使命，顺序完成了第二棒的拼接

;------------------------------------------------------------------------------- 
;功能:读取硬盘 n 个扇区
rd_disk_m_16: 
;------------------------------------------------------------------------------- 
; eax=LBA 扇区号
; bx=将数据写入的内存地址
; cx=读入的扇区数
mov esi,eax ;备份 eax，因为 al 在 out 指令中会被用到
mov di,cx ;备份 cx，cx 的值会在读取数据时用到，所以在此提前备份
;读写硬盘: 
;第 1 步:设置要读取的扇区数
mov dx,0x1f2 ; 往端口中写入数据用 out 指令，注意 out 指令中 dx 寄存器是用来存储端口号的,咱们的虚拟硬盘属于 ata0，是 Primary 通道，所以其 sector count 寄存器是由 0x1f2 端口来访问的
mov al,cl 
out dx,al ;读取的扇区数

mov eax,esi ;恢复 ax 
; 第 74～95 行是将 LBA 地址写入三个 LBA 寄存器和 device 寄存器的低 4 位
;第 2 步:将 LBA 地址存入 0x1f3 ～ 0x1f6 

;LBA 地址 7～0 位写入端口 0x1f3 
mov dx,0x1f3 
out dx,al 
 
;LBA 地址 15～8 位写入端口 0x1f4 
mov cl,8 
shr eax,cl ; shr 指令是逻辑右移指令，这里主要通过此指令置换出地址的相应部分，写入相应的 LBA 寄存器
mov dx,0x1f4 
out dx,al 
 
;LBA 地址 23～16 位写入端口 0x1f5 
shr eax,cl 
mov dx,0x1f5 
out dx,al 

shr eax,cl 
and al,0x0f ;lba 第 24～27 位
or al,0xe0 ; 设置 7～4 位为 1110,表示 lba 模式. 做或运算，拼出 device 寄存器的值。高 4 位为 e，即高 4 位的二进制表示为 1110，其第 5 位和第 7 位固定为 1，第 6 位为 1 表示启用 LBA
mov dx,0x1f6 
out dx,al 

;第 3 步:向 command 端口 0x1f7 端口写入读命令,0x20 
mov dx,0x1f7 
mov al,0x20 
out dx,al 

;第 4 步:检测硬盘状态：检测 status 寄存器的 BSY 位
.not_ready: 
;同一端口,写时表示写入命令字,读时表示读入硬盘状态
nop ; nop 表示空操作，即什么也不做，只是为了增加延迟，相当于 sleep 了一小下，目的是减少打扰硬盘的工作
in al,dx ;  Status 寄存器的值读入到 al 寄存器
and al,0x88 ;第 4 位为 1 表示硬盘控制器已准备好数据传输
 ;第 7 位为 1 表示硬盘忙
cmp al,0x08 
jnz .not_ready ;若未准备好,继续等
; 从硬盘取数据
;第 5 步:从 0x1f0 端口(data)读数据
mov ax, di ; di 为要读取的扇区数,一个扇区有 512 字节,每次读入一个字，即2个字节，共需 di*512/2 次,所以 di*256 
mov dx, 256 
mul dx ; 如果操作数是 8 位，被乘数就是 al 寄存器的值，乘积就是 16 位，位于 ax 寄存器。如果操作数是 16 位，被乘数就是 ax 寄存器的值，乘积就是 32位，积的高 16 位在 dx 寄存器，积的低 16 位在 ax 寄存器
mov cx, ax ; cx是循环次数
 
mov dx, 0x1f0 ; 0x1f0是data寄存器，用于从硬盘中读出数据
.go_on_read: ; 在第 118～122 行通过循环来将数据写入 bx 寄存器指向的内存，每读入 2 个字节，bx 所指的地址便+2。
in ax,dx 
mov [bx],ax 
add bx,2 
loop .go_on_read 
ret 

times 510-($-$$) db 0 
db 0x55,0xaa
```



然后是编译：

```shell
nasm -I include/ -o mbr.bin mbr.S
```

接下来用 dd 命令将 mbr.bin 写入虚拟硬盘

```shell
sudo dd if=./mbr.bin of=/usr/share/bochs/hd60M.img bs=512 count=1 conv=notrunc
```





#### （二）实现内核加载器

mbr把loader加载到内存0x900处，所以要实现一个loader，不然看不到效果啊。

```assembly
%include "boot.inc" 
section loader vstart=LOADER_BASE_ADDR

; 输出背景色绿色,前景色红色,并且跳动的字符串"My LOADER" 
mov byte [gs:0x00],'2' 
mov byte [gs:0x01],0xA4 ; A 表示绿色背景闪烁，4 表示前景色为红色

mov byte [gs:0x02],' ' 
mov byte [gs:0x03],0xA4 

mov byte [gs:0x04],'L' 
mov byte [gs:0x05],0xA4 

mov byte [gs:0x06],'O' 
mov byte [gs:0x07],0xA4 
 
mov byte [gs:0x08],'A' 
mov byte [gs:0x09],0xA4 

mov byte [gs:0x0a],'D' 
mov byte [gs:0x0b],0xA4 

mov byte [gs:0x0c],'E' 
mov byte [gs:0x0d],0xA4 

mov byte [gs:0x0e],'R' 
mov byte [gs:0x0f],0xA4 

jmp $
```



编译：

```shell
nasm -I include/ -o loader.bin loader.S
```

将生成的 loader.bin 写入硬盘第 2 个扇区。第 0 个扇区是 MBR，第 1 个扇区是空的未使用，原因如前所述，纯粹个人喜好。

```shell
dd if=./loader.bin of=/usr/share/bochs/hd60M.img bs=512 count=1 seek=2 conv=notrunc
```

``sudo bin/bochs -f bochsrc.disk`启动bochs模拟的x86机器，效果如图：

![pictures (26)](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205042224111.jpg)

左边是”My LOADER“闪烁没了，右边是”My LOADER"闪烁出来了。



## 七、预告

这个 loader 目前还没有实际意义，目前只是来验证 MBR 和 loader 的接力是否成功，它最终的任务是要加载内核。可是内核运行在 32位保护模式环境下，我们当前还在实模式下呢。首先咱们得知道什么是保护模式，其次还得想办法进入到保护模式。

我们接下来学习保护模式。
