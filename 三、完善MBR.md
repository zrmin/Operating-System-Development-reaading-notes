<h1><center>完善MBR</center></h1>

## 一、地址、section、vstart

#### （一）什么是地址

编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。

地址 = 前一个指令的地址+前一个指令的大小。

上图为证：

![image-20220502175311459](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205021753535.png)

图中，很明显：$一个指令的地址 = 上一个指令的地址 + 上一个指令的大小$



#### （二）什么是section

编译器提供的关键字 Section 只是为了让程序员在逻辑上将程序划分成几个部分。

![image-20220502200431947](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022004048.png)

关键字 section 并没有对程序中的地址产生任何影响，即在默认情况下，有没有 section 都一个样，section 中数据的地址依然是相对于整个文件的顺延，仅仅是在逻辑上让开发人员梳理程序之用。



#### （三）什么是vstart

vstart 的作用是为 section 内的数据指定一个虚拟的起始地址，也就是根据此地址，在文件中是找不到相关数据的，是虚拟的，假的，文件中的所有符号都不在这个地址上。

![image-20220502200727460](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022007501.png)

大概意思是 section 用 vstart=来修饰后，可以被赋予一个虚拟起始地址 virtual start address（强调了这个是虚拟的地址，不过要注意，这与 x86 CPU 中开启分页后的虚拟地址是两码事，不能混为一谈），它被用来计算在该 section 内的所有内存引用地址。

地址访问策略是根据程序中给出的地址，到地址处去拿东西，所以这个东西要提前在那个地址处准备好了才行，这是永恒不变的。程序中给出的地址，最终是要用来访问物理内存的，所以该地址对应的物理内存必须是你想要的才行，换句话说，必须保证自己想要的东西被加载到那个物理内存位置。这就是程序加载器做的事，根据文件头中给出的各段的位置，将它们加载到内存中的相应地址，这样用户程序才能访问到自己需要的东西。

![image-20220502203938978](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022039050.png)

**这里有一个大家常见的陷阱**：vstart=xxxx 和 org xxxx 这两个关键字是同一功能，但很多人都混淆其意义。它们并不是告诉编译器把程序加载到地址 xxxx，这似乎一听，好像是编译器有加载器的功能了，“加载”不是编译器的工作，这是加载器的工作，编译器只会规划代码——只会为程序编址，并不负责加载。

正确的理解是：vstart 和 org，它们的功能是告诉编译器：“你把我后面所有数据（指令和变量）的地址以 xxxx 为起始地址进行编址”。

只有开发人员知道以xxxx 为起始地址的原因是将来有某个加载器要把我的这个程序放到内存的 xxxx 地址，如果我程序中引用的所有地址不是以 xxxx 为起始的，那就会访问错误的数据。但编译器并不知道这些，它会帮你按照vstart=xxxx这个起始地址，对本section中的指令、数据进行编址。

所以说，用 vstart 的时机是：我预先知道我的程序将来被加载到某地址处。程序只有加载到非 0 地址时 vstart 才是有用的，程序默认起始地址是 0。

编译器只负责编址，它只会将数据相对于文件开头的偏移量作为该数据的地址，全是以0 起始的。编译器以相对于文件开头偏移来编址的好处是利于重定位。整个文件新加载到某个地址后，可以以这个地址为段基址，文件内的数据的地址是以 0 为开始算的，所以它们直接就可以用作段内偏移地址了。

vstart 只是告诉编译器以新的数字作为后面数据的地址的起始值，它本身没改变数据本身在文件中的地址（相对于文件开头的偏移）。

就像我们前面编写的MBR代码一样。mbr 用 vstart=0x7c00 来修饰的原因，是因为开发人员知道 mbr 要被加载器（BIOS）加载到物理地址0x7c00，mbr 中后续的物理地址都是 0x7c00+。另外，因为 BIOS 进入 mbr 是通过 jmp 0：7c00 来实现的，故此时 cs 已经变成 0，相当于“平坦模型”了，只不过此“平坦模型”大小只是$2^{16}$字节，而不是 4GB。所以 mbr 中各数据编译出来的地址（大于等于 0x7c00）实际上都成了偏移地址，这样`0*16：偏移地址0x7c00+`来访问被加载到 0x7c00 的 mbr 是正确无误的。



## 二、CPU实模式

实模式是指 8086 CPU 的寻址方式、寄存器大小、指令用法等，是用来反应 CPU 在该环境下如何工作的概念。

所以想了解实模式这种抽象的概念，主要就是了解在实模式下 CPU 能做什么。

#### （一）CPU的工作原理

至于为什么要讲一下CPU的工作原理，是因为无论CPU在哪种模式下工作，工作原理都是不变的。

具体的原理《ics》和其他的一些书上都有，简要总结一下：

<i>控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs：ip。于是读取 ip 寄存器后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中。这时候轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程。操作码有了，操作数也齐了，操作控制器给运算单元发送控制信号，于是运算单元便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址。接着控制单元又要取下一条指令了，流程回到了本段开头，CPU周而复始。</i>



CPU 大体上可以划分为 3 个部分：

1. 控制单元：控制单元是 CPU 的控制中心，CPU 需要经过它的帮忙才知道自己下一步要做什么。而控制单元大致由指令寄存器 IR（Instruction Register）、指令译码器 ID（Instruction Decoder）、操作控制器 OC（Operation Controller）组成。
2. 运算单元
3. 存储单元：存储单元是指 CPU 内部的 L1、L2 缓存及寄存器，操作数就存放在这些存储单元中



程序被加载到内存后，也就是指令这时都在内存中了，指令指针寄存器 IP 指向内存中下一条待执行指令的地址，控制单元根据 IP 寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中，但它还是不知道这些指令是什么，在它眼里的 0101 串此时还没有实际意义。然后指令译码器将位于指令寄存器中的指令按照指令格式来解码，分析出操作码是什么，操作数在哪里之类的。

IA32的指令格式如下：

| 前缀 | 操作码 | 寻址方式、操作数类型 | 立即数 | 偏移量 |
| :--: | :----: | :------------------: | :----: | :----: |

* 前缀：由于 intel CPU 支持的指令数量较多，一些指令还可以搭配一些辅助的功能，所以就需要在前缀部分记录。如 rep（用于重复执行，汇编中经常用）、段超越前缀。

* 操作码：操作码就是大家平时用的 mov、jmp 等
* 寻址方式、操作数类型：寻址方式又有好多，如基址寻址、变址寻址等，操作数类型中记录的是用哪些寄存器之类的
* 立即数：如果在指令中用到了立即数，就要将其记录到指令格式中立即数的部分
* 偏移量：如果寻址方式中用到了偏移量，就要将此偏移量记录到指令格式中的偏移量部分



寄存器可分为两大类，程序员可以使用的寄存器称为程序可见寄存器，如通用寄存器、段寄存器。程序不可见寄存器是指程序员不可使用，也无法访问到它们，系统运行期间可能要用到的寄存器，如 ALU 算术逻辑单元在求和时，会将结果先送到数据暂存寄存器。



#### （二）实模式下的寄存器

CPU中的寄存器分为两类：（这种划分方法和老大的有些不一样）

1. 不可见寄存器，也就是对程序员不能使用。
   * 全局描述符表寄存器 GDTR
   * 中断描述符表寄存器 IDTR
   * 局部描述符表寄存器 LDTR
   * 任务寄存器 TR
   * 控制寄存器 CR0～3
   * 指令指针寄存器 IP
   * 标志寄存器 flags
   * 调试寄存器 DR0～7
2. 可见寄存器，我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器。

![image-20220502211918141](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119985.png)

在 16 位 CPU 中，只有一个附加段寄存器—ES。而FS 和 GS 附加段寄存器是在 32 位CPU 中增加的。我们使用的是 32 位 CPU，并不是说 32 位 CPU 在实模式下的 16 位环境中就不能用 FS 和GS 寄存器。32 位的 CPU 兼容 16 位 CPU 的特性。



![image-20220502211942142](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119965.png)

在执行当前指令的同时，在不跨段的情况下，CPU 以“当前 IP 寄存器中的值+当前执行指令的机器码长度”的和作为新的代码段内偏移地址，将其存入 IP 寄存器，再到该新地址处读取指令并执行。如果下一条指令需要跨段访问，还要加载新的段基址到CS 段寄存器。

![image-20220502211959036](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022119861.png)

flags寄存器：任何一个指令的执行、其执行过程的细节、对计算机造成了哪些影响，都在 flags 寄存器中通过一些标志位反映出来



通用寄存器：

无论是实模式，还是保护模式，通用寄存器有 8 个，分别是 AX、BX、CX、DX、SI、DI、BP、SP

![image-20220502212516058](https://raw.githubusercontent.com/zrmin/BlogImages/master/images/202205022125101.png)

在32位CPU，AX、BX、CX、DX被扩展成32位，变成了EAX、EBX、ECX、EDX，这里提及了寄存器 eax等 的原因是在实模式下虽然操作数是 16 位，但依然可以用 32 位的寄存器，因为我们所讲的是 32 位 CPU 在实模式下的工作状态，并不是纯粹的8086这样的16位CPU。

| 寄存器 |              助记名称               |                           功能描述                           |
| :----: | :---------------------------------: | :----------------------------------------------------------: |
|   ax   |        累加器（accumulator）        | 使用频度最高，常用于算术运算、逻辑运算、保存与外设输入输出的数据 |
|   bx   |         基址寄存器（base）          |  常用来存储内存地址，用此地址作为基址，用来遍历一片内存区域  |
|   cx   |          计数器（counter）          | 顾名思义，计数器的作用就是计数，所以常用于循环指令中的循环次数 |
|   dx   |         数据寄存器（data）          |  可用于存放数据，通常情况下只用于保存外设控制器的端口号地址  |
|   si   |    源变址寄存器（source index）     | 常用于字符串操作中的数据源地址，即被传送的数据在哪里。通常需要与其他指令配合使用，如批量数据传送指令族 movs[bwd] |
|   di   | 目的变址寄存器（destination index） | 和 si 一样，常用于字符串操作。但 di 是用于数据的目的地址，即数据被传送到哪里 |
|   sp   |    栈指针寄存器（stack pointer）    | 其段基址是 SS，用来指向栈顶。随着栈中数据的进出，push 和 pop 这两个对栈操作的指令会修改 sp 的值 |
|   bp   |      基址指针（base pointer）       | 访问栈有两种方式，一种是用 push 和 pop 指令操作栈，sp 指针的值会自动更新，但我 |

bp: 访问栈有两种方式，一种是用 push 和 pop 指令操作栈，sp 指针的值会自动更新，但我们只能获取栈顶 sp 指针指向的数据。很多时候，我们需要读写在栈底和栈顶之间的数据，处理器为了让开发人员方便控制栈中数据，还提供了把栈当成数据段来访问的方式，即提供了寄存器 bp，所以 bp 默认的段寄存器就是 SS，可通过 SS：bp 的方式把栈当成普通的数据段来访问，只不过 bp 不像 sp 那样随 push、pop 自动改变



#### （三）实模式下内存分段的由来



#### （四）实模式下CPU内存寻址方式



#### （五）栈到底是什么玩意儿



#### （六）实模式下的ret



#### （七）实模式下的call



#### （八）实模式下的jmp



#### （九）标志寄存器flag



#### （十）有条件转移



#### （十一）实模式小结





## 三、让我们直接对显示器说点什么吧

#### （一）CPU如何与外设通信——IO接口



#### （二）显卡概述



#### （三）显存、显卡、显示器



#### （四）改进MBR，直接操作显卡





## 四、bochs调试方法

#### （一）bochs一般用法



#### （二）bochs调试实例



## 五、硬盘介绍

#### （一）硬盘发展简史



#### （二）硬盘工作原理



#### （三）硬盘控制器端口



#### （四）常用的硬盘操作方法



## 六、让MBR使用硬盘

#### （一）改造MBR



#### （二）实现内核加载器

